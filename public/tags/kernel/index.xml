<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kernel on Qdiv7</title>
    <link>https://mohandacherir.github.io/Qdiv7/tags/kernel/</link>
    <description>Recent content in Kernel on Qdiv7</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 20 Jan 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mohandacherir.github.io/Qdiv7/tags/kernel/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Notes on io_uring bugs &amp; exploitation</title>
      <link>https://mohandacherir.github.io/Qdiv7/posts/io_uring_exploitation/</link>
      <pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://mohandacherir.github.io/Qdiv7/posts/io_uring_exploitation/</guid>
      <description>&lt;p&gt;In this blog post, i go through the definitions and basics of io_uring subsystem, and then i talk about bugs and their exploits. &lt;br&gt;&#xA;&lt;strong&gt;io_uring&lt;/strong&gt; has been a very targeted subsystem in the linux kernel, to a point where it constituted 60% of kCTF entries; and as most newly introduced features, io_uring - since its introduction in 2019 - has been very bug-prone.&lt;/p&gt;&#xA;&lt;h2 id=&#34;introduction&#34;&gt;Introduction:&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;io_uring&lt;/strong&gt; is an API for asynchronous I/O operations.&#xA;Rather than using the traditional syscalls(read, write&amp;hellip;etc), io_uring allows through its API to make zero-copy operations with minimal overhead to communicate with the kernel&#xA;and make the same operations that these syscalls would do. It uses shared buffers between userspace and kernel as a mean for communication and tranferring data.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on refcounting and Unix Garbage Collector in the Linux Kernel</title>
      <link>https://mohandacherir.github.io/Qdiv7/posts/refcounting-linux-kernel/</link>
      <pubDate>Tue, 23 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://mohandacherir.github.io/Qdiv7/posts/refcounting-linux-kernel/</guid>
      <description>&lt;p&gt;As a means of studying and getting to know more about the linux kernel, especially exploitation(LPE &amp;amp; RCE), i tried to make notes and go as far as i can in reviewing the &lt;strong&gt;unix garbage&lt;/strong&gt;, or &lt;strong&gt;GC&lt;/strong&gt;, collector, the &lt;strong&gt;io_uring&lt;/strong&gt; subsystem, and some CVEs that showcase all of these. I am currently working on an N-day LPE for CVE-2022-2602 LPE to make it work with &lt;strong&gt;FUSE&lt;/strong&gt; technique.&lt;/p&gt;&#xA;&lt;p&gt;To kick off this article, i will explain the basics of &lt;strong&gt;file structures&lt;/strong&gt;, &lt;strong&gt;sockets&lt;/strong&gt;&amp;hellip;etc in the kernel, and then move onto to the unix GC and io_uring, and i&amp;rsquo;ll wrap with the CVEs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Notes on Linux Internals: The Slab Allocator</title>
      <link>https://mohandacherir.github.io/Qdiv7/posts/notes-on-linux-internals-the-slab-allocator/</link>
      <pubDate>Sat, 06 Sep 2025 00:00:00 +0000</pubDate>
      <guid>https://mohandacherir.github.io/Qdiv7/posts/notes-on-linux-internals-the-slab-allocator/</guid>
      <description>&lt;h1 id=&#34;linux-slub-allocator&#34;&gt;Linux SLUB allocator&lt;/h1&gt;&#xA;&lt;p&gt;The Linux kernel is responsible for managing the available physical memory that it needs to satisfy memory allocation/de-allocation requests coming from different sources like device drivers, usermode processes, filesystems etc. It needs to ensure that it efficiently serves these requests under the specified constraints (if any) and to do so it relies on different types of memory allocators. Each allocator has its own interface and underlying implementation. The three main memory allocators used by the kernel are:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

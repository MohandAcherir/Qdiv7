<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
        }
    </style>

    
    
    
    
    
    

    
    <title>Notes on io_uring bugs &amp; exploitation</title>
    <meta name="description" content="Notes on io_uring bugs and exploitation In this blog post, i go through the definitions and basics of io_uring subsystem, and then i talk about bugs and their …">
    <meta name="keywords" content='exploit, kernel'>

    <meta property="og:url" content="https://mohandacherir.github.io/Qdiv7/posts/io_uring_exploitation/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Notes on io_uring bugs &amp; exploitation">
    <meta property="og:description" content="Notes on io_uring bugs and exploitation In this blog post, i go through the definitions and basics of io_uring subsystem, and then i talk about bugs and their …">
    <meta property="og:image" content="https://mohandacherir.github.io/Qdiv7/images/0074.png">
    <meta property="og:image:secure_url" content="https://mohandacherir.github.io/Qdiv7/images/0074.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Notes on io_uring bugs &amp; exploitation">
    <meta name="twitter:description" content="Notes on io_uring bugs and exploitation In this blog post, i go through the definitions and basics of io_uring subsystem, and then i talk about bugs and their …">
    <meta property="twitter:domain" content="https://mohandacherir.github.io/Qdiv7/posts/io_uring_exploitation/">
    <meta property="twitter:url" content="https://mohandacherir.github.io/Qdiv7/posts/io_uring_exploitation/">
    <meta name="twitter:image" content="https://mohandacherir.github.io/Qdiv7/images/0074.png">

    
    <link rel="canonical" href="https://mohandacherir.github.io/Qdiv7/posts/io_uring_exploitation/">

    
    <link rel="stylesheet" type="text/css" href="/Qdiv7/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/Qdiv7/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/Qdiv7/css/dark.min.css">

    
    <script src="/Qdiv7/js/bundle.min.d802ac8af929bbc3ab5644409ae296a7b841359132018cdcd4848e2e300fa8d8.js" integrity="sha256-2AKsivkpu8OrVkRAmuKWp7hBNZEyAYzc1ISOLjAPqNg="></script>

    
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        
        <div class="avatar">
            <a href="https://mohandacherir.github.io/Qdiv7/">
                <img src='images/0074.png' alt="avatar">
            </a>
        </div>
        

        <div class="nav-title">
            <a class="nav-brand" href="https://mohandacherir.github.io/Qdiv7/">Qdiv7</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://mohandacherir.github.io/Qdiv7/posts/" aria-label="" > Posts </a>
            </div>
            
            <div class="nav-link">
                <a href="https://mohandacherir.github.io/Qdiv7/tags/" aria-label="" > Tags </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com/MohandAcherir" aria-label="github" ><span data-feather='github'></span>  </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                <a aria-hidden="true" role="switch">
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a aria-checked="false" aria-labelledby="hamburger-menu-toggle" id="hamburger-menu-toggle-target" role="switch">
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://mohandacherir.github.io/Qdiv7/posts/" > Posts </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://mohandacherir.github.io/Qdiv7/tags/" > Tags </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com/MohandAcherir" ><span data-feather='github'></span>  </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a role="switch">
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>Notes on io_uring bugs &amp; exploitation</h1>

        

        
	
	
	
	
        

	

	

	
          <small role="doc-subtitle"></small>
	

	
          <p class="post-date">January 20, 2026
           
          </p>
	

        <ul class="post-tags">
          
           
             <li class="post-tag"><a href="https://mohandacherir.github.io/Qdiv7/tags/exploit">exploit</a></li>
           
         
           
             <li class="post-tag"><a href="https://mohandacherir.github.io/Qdiv7/tags/kernel">kernel</a></li>
           
         
        </ul>
    </div>

    <div class="post-content">
        <h1 id="notes-on-io_uring-bugs-and-exploitation">Notes on io_uring bugs and exploitation</h1>
<p>In this blog post, i go through the definitions and basics of io_uring subsystem, and then i talk about bugs and their exploits. <br>
<strong>io_uring</strong> has been a very targeted subsystem in the linux kernel, to a point where it constituted 60% of kCTF entries; and as most newly introduced features, io_uring - since its introduction in 2019 - has been very bug-prone.</p>
<h2 id="introduction">Introduction:</h2>
<p><strong>io_uring</strong> is an API for asynchronous I/O operations.
Rather than using the traditional syscalls(read, write&hellip;etc), io_uring allows through its API to make zero-copy operations with minimal overhead to communicate with the kernel
and make the same operations that these syscalls would do. It uses shared buffers between userspace and kernel as a mean for communication and tranferring data.</p>
<p>As per the doc, we follow these steps to make use for this feature:</p>
<ol>
<li>Set up the shared buffers(or shared queues) with:</li>
</ol>
<ul>
<li><code>io_uring_setup</code>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;liburing.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_uring_setup</span>(u32 entries, <span style="color:#66d9ef">struct</span> io_uring_params <span style="color:#f92672">*</span>params);
</span></span></code></pre></div><p>The <code>io_uring_setup</code> system call sets up a submission queue (SQ) and completion queue (CQ) with at least <code>entries</code> entries, and returns a file descriptor which can be used to perform subsequent operations on the io_uring instance. As state before, the submission and completion queues are shared between userspace and the kernel, which eliminates the need to copy data when initiating and completing I/O.</p>
<p><code>params</code> is used by the application to pass options to the kernel, and by the kernel to convey information about the ring buffers.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>           <span style="color:#66d9ef">struct</span> io_uring_params {
</span></span><span style="display:flex;"><span>               __u32 sq_entries;
</span></span><span style="display:flex;"><span>               __u32 cq_entries;
</span></span><span style="display:flex;"><span>               __u32 flags;
</span></span><span style="display:flex;"><span>               __u32 sq_thread_cpu;
</span></span><span style="display:flex;"><span>               __u32 sq_thread_idle;
</span></span><span style="display:flex;"><span>               __u32 features;
</span></span><span style="display:flex;"><span>               __u32 wq_fd;
</span></span><span style="display:flex;"><span>               __u32 resv[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">struct</span> io_sqring_offsets sq_off;
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">struct</span> io_cqring_offsets cq_off;
</span></span><span style="display:flex;"><span>           };
</span></span></code></pre></div><p><strong><code>flags</code></strong>: It can take multiple(or 0) options that are OR(|)ed -&gt; IORING_SETUP_IOPOLL, IORING_SETUP_HYBRID_IOPOLL, &hellip;etc <br>
If no flags are specified, the io_uring instance is setup for interrupt driven I/O. <br>
The resv array must be initialized to zero. \</p>
<p>The rest of the fields are filled in by the kernel, and provide the information necessary to memory map(to get access from userspace) the submission queue, completion queue, and the array of submission queue entries. <br>
<code>sq_entries</code> specifies the number of submission queue entries allocated and <code>sq_off</code> describes the offsets of various ring buffer fields:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>           <span style="color:#66d9ef">struct</span> io_sqring_offsets {
</span></span><span style="display:flex;"><span>               __u32 head;
</span></span><span style="display:flex;"><span>               __u32 tail;
</span></span><span style="display:flex;"><span>               __u32 ring_mask;
</span></span><span style="display:flex;"><span>               __u32 ring_entries;
</span></span><span style="display:flex;"><span>               __u32 flags;
</span></span><span style="display:flex;"><span>               __u32 dropped;
</span></span><span style="display:flex;"><span>               __u32 array;
</span></span><span style="display:flex;"><span>               __u32 resv1;
</span></span><span style="display:flex;"><span>               __u64 user_addr;
</span></span><span style="display:flex;"><span>           };
</span></span></code></pre></div><p>So, basically, the <strong>submission queue</strong> can be mapped like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>           ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap</span>(<span style="color:#ae81ff">0</span>, sq_off.array <span style="color:#f92672">+</span> sq_entries <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(__u32),
</span></span><span style="display:flex;"><span>                      PROT_READ<span style="color:#f92672">|</span>PROT_WRITE, MAP_SHARED<span style="color:#f92672">|</span>MAP_POPULATE,
</span></span><span style="display:flex;"><span>                      ring_fd, IORING_OFF_SQ_RING);
</span></span></code></pre></div><p>where <code>ring_fd</code> is the fd returned from <code>io_uring_setup</code>.</p>
<p>The array of <strong>submission queue entries</strong> is mapped with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>           sqentries <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap</span>(<span style="color:#ae81ff">0</span>, sq_entries <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> io_uring_sqe),
</span></span><span style="display:flex;"><span>                            PROT_READ<span style="color:#f92672">|</span>PROT_WRITE, MAP_SHARED<span style="color:#f92672">|</span>MAP_POPULATE,
</span></span><span style="display:flex;"><span>                            ring_fd, IORING_OFF_SQES);
</span></span></code></pre></div><p>The completion queue is simpler, since the entries are not separated from the queue itself unlike the submission queue, and can be mapped with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>           ptr <span style="color:#f92672">=</span> <span style="color:#a6e22e">mmap</span>(<span style="color:#ae81ff">0</span>, cq_off.cqes <span style="color:#f92672">+</span> cq_entries <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> io_uring_cqe),
</span></span><span style="display:flex;"><span>                      PROT_READ<span style="color:#f92672">|</span>PROT_WRITE, MAP_SHARED<span style="color:#f92672">|</span>MAP_POPULATE, ring_fd,
</span></span><span style="display:flex;"><span>                      IORING_OFF_CQ_RING);
</span></span></code></pre></div><ol start="2">
<li>For every I/O request you need to make (like to read a file, write a file, accept a socket connection, etc), you create a <strong>submission queue entry</strong>, or SQE, describe the I/O operation you need to get done and add it to the tail of the submission queue (SQ). One or more entries can be added.  <br>
Each I/O operation is, in essence, the equivalent of a system call you would have made otherwise, if you were not using io_uring. <br>
For instance, a SQE with the opcode set to <strong>IORING_OP_READ</strong> is equivalent to the <code>read</code> system call. <br>
As you may have guessed, there are other opcodes: <strong>IORING_OP_WRITE</strong>, <strong>IORING_OP_SOCKET</strong>, <strong>IORING_OP_LISTEN</strong> ..etc</li>
</ol>
<p>Concretely, we add an entry into the <strong>submission queue</strong> with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Retrieving entries array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sring_array <span style="color:#f92672">=</span> sq_ptr <span style="color:#f92672">+</span> p.sq_off.array; <span style="color:#75715e">// the mmaped address of SQ + sq_off.array: get the entries address 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// retieving a new index from tail[....]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Specifying the operation to do
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> io_uring_sqe <span style="color:#f92672">*</span>sqe <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sqes[index]; <span style="color:#75715e">// using the index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sqe<span style="color:#f92672">-&gt;</span>opcode <span style="color:#f92672">=</span> IORING_OP_READ;
</span></span><span style="display:flex;"><span>sqe<span style="color:#f92672">-&gt;</span>fd <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// read from stdin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sqe<span style="color:#f92672">-&gt;</span>addr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) buff; <span style="color:#75715e">// into buff
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ....
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Call io_uring_enter(...) to perform the operation
</span></span></span></code></pre></div><ol start="3">
<li>Sumbit:</li>
</ol>
<p><strong>Note:</strong> you can forget all of this, and use <code>liburing.h</code> that highly simplifies usage.</p>
<h2 id="vulnerability-review-cve-2021-41073">Vulnerability Review: CVE-2021-41073</h2>
<p>Credits: <a href="https://twitter.com/chompie1337">@chompie</a></p>
<p>In order to read/write into files, we can either supply buffers, or let the kernel choose pre-registered buffers with function <a href="https://elixir.bootlin.com/linux/v5.15-rc1/source/fs/io_uring.c#L6678"><code>io_provide_buffers</code></a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_provide_buffers</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> issue_flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_provide_buf <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>req<span style="color:#f92672">-&gt;</span>pbuf;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_ring_ctx <span style="color:#f92672">*</span>ctx <span style="color:#f92672">=</span> req<span style="color:#f92672">-&gt;</span>ctx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	list <span style="color:#f92672">=</span> head <span style="color:#f92672">=</span> <span style="color:#a6e22e">xa_load</span>(<span style="color:#f92672">&amp;</span>ctx<span style="color:#f92672">-&gt;</span>io_buffers, p<span style="color:#f92672">-&gt;</span>bgid);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_add_buffers</span>(p, <span style="color:#f92672">&amp;</span>head);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This function allocates kernel side objects <code>struct io_buffer</code> that contain the userspace provided buffer addresses from which to choose from.</p>
<p>For this second case, where kernel chooses an allocated buffer (<code>struct io_buffer</code>), at selection time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span><span style="color:#a6e22e">io_buffer_select</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">size_t</span> <span style="color:#f92672">*</span>len,
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">int</span> bgid, <span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>kbuf,
</span></span><span style="display:flex;"><span>					  <span style="color:#66d9ef">bool</span> needs_lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>head;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	head <span style="color:#f92672">=</span> <span style="color:#a6e22e">xa_load</span>(<span style="color:#f92672">&amp;</span>req<span style="color:#f92672">-&gt;</span>ctx<span style="color:#f92672">-&gt;</span>io_buffers, bgid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (head) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">list_empty</span>(<span style="color:#f92672">&amp;</span>head<span style="color:#f92672">-&gt;</span>list)) {
</span></span><span style="display:flex;"><span>			kbuf <span style="color:#f92672">=</span> <span style="color:#a6e22e">list_last_entry</span>(<span style="color:#f92672">&amp;</span>head<span style="color:#f92672">-&gt;</span>list, <span style="color:#66d9ef">struct</span> io_buffer,
</span></span><span style="display:flex;"><span>							list);
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">list_del</span>(<span style="color:#f92672">&amp;</span>kbuf<span style="color:#f92672">-&gt;</span>list);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> kbuf;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>function <code>io_rw_buffer_select</code> is called to select and return a working buffer <code>kbuf-&gt;addr</code> which is the provided userspace pointer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span><span style="color:#a6e22e">io_rw_buffer_select</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">size_t</span> <span style="color:#f92672">*</span>len,
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">bool</span> needs_lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>kbuf;
</span></span><span style="display:flex;"><span>	u16 bgid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	kbuf <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>) (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) req<span style="color:#f92672">-&gt;</span>rw.addr;
</span></span><span style="display:flex;"><span>	bgid <span style="color:#f92672">=</span> req<span style="color:#f92672">-&gt;</span>buf_index;
</span></span><span style="display:flex;"><span>	kbuf <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_buffer_select</span>(req, len, bgid, kbuf, needs_lock);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ERR</span>(kbuf))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> kbuf;
</span></span><span style="display:flex;"><span>	req<span style="color:#f92672">-&gt;</span>rw.addr <span style="color:#f92672">=</span> (u64) (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) kbuf; <span style="color:#75715e">// [1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	req<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|=</span> REQ_F_BUFFER_SELECTED; <span style="color:#75715e">// [2]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">u64_to_user_ptr</span>(kbuf<span style="color:#f92672">-&gt;</span>addr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After selecting a buffer at [1], the request is flagged with <code>REQ_F_BUFFER_SELECTED</code> as a way to track the buffer selection [2].</p>
<p>But some confusion happened, because <code>req-&gt;rw.addr</code> is meant to be a userspace pointer, yet here, it is initialized with a kernel address of an <code>struct io_buffer</code> object in [1]. <br>
And more critically, for files that do not have <code>-&gt;read_iter() / -&gt;write_iter()</code> handlers like those in <code>/proc</code> , <code>req-&gt;rw.addr</code> is used as a user space pointer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * For files that don&#39;t have -&gt;read_iter() and -&gt;write_iter(), handle them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * by looping over -&gt;read() or -&gt;write() manually.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">loop_rw_iter</span>(<span style="color:#66d9ef">int</span> rw, <span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">struct</span> iov_iter <span style="color:#f92672">*</span>iter)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> kiocb <span style="color:#f92672">*</span>kiocb <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>req<span style="color:#f92672">-&gt;</span>rw.kiocb;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file <span style="color:#f92672">=</span> req<span style="color:#f92672">-&gt;</span>file;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">ssize_t</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">iov_iter_count</span>(iter)) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">struct</span> iovec iovec;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">ssize_t</span> nr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">iov_iter_is_bvec</span>(iter)) {
</span></span><span style="display:flex;"><span>			iovec <span style="color:#f92672">=</span> <span style="color:#a6e22e">iov_iter_iovec</span>(iter);
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			iovec.iov_base <span style="color:#f92672">=</span> <span style="color:#a6e22e">u64_to_user_ptr</span>(req<span style="color:#f92672">-&gt;</span>rw.addr);
</span></span><span style="display:flex;"><span>			iovec.iov_len <span style="color:#f92672">=</span> req<span style="color:#f92672">-&gt;</span>rw.len;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (rw <span style="color:#f92672">==</span> READ) {
</span></span><span style="display:flex;"><span>			nr <span style="color:#f92672">=</span> file<span style="color:#f92672">-&gt;</span>f_op<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">read</span>(file, iovec.iov_base,
</span></span><span style="display:flex;"><span>					      iovec.iov_len, <span style="color:#a6e22e">io_kiocb_ppos</span>(kiocb));
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			nr <span style="color:#f92672">=</span> file<span style="color:#f92672">-&gt;</span>f_op<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">write</span>(file, iovec.iov_base,
</span></span><span style="display:flex;"><span>					       iovec.iov_len, <span style="color:#a6e22e">io_kiocb_ppos</span>(kiocb));
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nr <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ret)
</span></span><span style="display:flex;"><span>				ret <span style="color:#f92672">=</span> nr;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">+=</span> nr;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (nr <span style="color:#f92672">!=</span> iovec.iov_len)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		req<span style="color:#f92672">-&gt;</span>rw.len <span style="color:#f92672">-=</span> nr;
</span></span><span style="display:flex;"><span>		req<span style="color:#f92672">-&gt;</span>rw.addr <span style="color:#f92672">+=</span> nr; <span style="color:#75715e">// [3]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">iov_iter_advance</span>(iter, nr);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>req-&gt;rw.addr</code> is incremented after each iteration by the number of bytes <code>nr</code> that have been read/written [3]. This function is triggered with any of io_uring opcodes: <code>IORING_OP_WRITEV</code> ,<code>IORING_OP_WRITE_FIXED</code> or <code>IORING_OP_WRITE</code>.</p>
<p>Upon request completion, <code>io_put_rw_kbuf</code> is called on the request object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_put_rw_kbuf</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>kbuf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">likely</span>(<span style="color:#f92672">!</span>(req<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> REQ_F_BUFFER_SELECTED))) <span style="color:#75715e">// [4] 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	kbuf <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>) (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) req<span style="color:#f92672">-&gt;</span>rw.addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">io_put_kbuf</span>(req, kbuf);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">==&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_put_kbuf</span>(<span style="color:#66d9ef">struct</span> io_kiocb <span style="color:#f92672">*</span>req, <span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>kbuf)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> cflags;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	cflags <span style="color:#f92672">=</span> kbuf<span style="color:#f92672">-&gt;</span>bid <span style="color:#f92672">&lt;&lt;</span> IORING_CQE_BUFFER_SHIFT;
</span></span><span style="display:flex;"><span>	cflags <span style="color:#f92672">|=</span> IORING_CQE_F_BUFFER;
</span></span><span style="display:flex;"><span>	req<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>REQ_F_BUFFER_SELECTED; <span style="color:#75715e">// Removing REQ_F_BUFFER_SELECTED flag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">kfree</span>(kbuf); <span style="color:#75715e">// [5]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> cflags;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>These two functions check that <code>req-&gt;rw.addr</code> is a selected buffer(REQ_F_BUFFER_SELECTED) and then free it with <code>kfree(kbuf)</code> in [5], which is actually <code>kfree(kbuf+number of processed bytes)</code> in function <code>loop_rw_iter</code>.</p>
<p>And since <code>struct io_buffer</code> is 32-byte structure and is allocated without cache isolation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_add_buffers</span>(<span style="color:#66d9ef">struct</span> io_provide_buf <span style="color:#f92672">*</span>pbuf, <span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">**</span>head)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_buffer <span style="color:#f92672">*</span>buf;
</span></span><span style="display:flex;"><span>	u64 addr <span style="color:#f92672">=</span> pbuf<span style="color:#f92672">-&gt;</span>addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> i, bid <span style="color:#f92672">=</span> pbuf<span style="color:#f92672">-&gt;</span>bid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> pbuf<span style="color:#f92672">-&gt;</span>nbufs; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>		buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>buf), GFP_KERNEL); <span style="color:#75715e">// No cache isolation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, we get a relative arbitrary free primitive in the kmalloc-32 cache slab.</p>
<p><img src="/Qdiv7/images/io_uring/corrputed_slab.png" alt="Image slab"></p>
<h3 id="exploitation">Exploitation:</h3>
<p>The goal like for most exploitation cases is to get a leaking primitive to get slab addresses and function pointer addresses to bypass KASLR,  and an object overwriting primitive to redirect control flow. <br>
This arbitrary free can turned into a leaking and overwriting primitives, simply by freeing kmalloc-32 cache objects that are can be read like <code>struct shm_file_data</code> and <code>seq_operations</code>, <code>struct io_buffer</code>, adding to that the <code>setxattr</code>(+FUSE/userfaultfd) than can allocate any size and the user can read/write any data in it.</p>
<h2 id="vulnerability-review-cve-2024-0582">Vulnerability Review: CVE-2024-0582</h2>
<p><strong>Note</strong>: The following is code is from v6.5.3, which differs from the previous one interms of io_uring features.</p>
<p>As new feature since v6.4, the kernel can handle the registering of io_buffers without the user providing userspace buffers.</p>
<h3 id="registering-io-buffers">Registering io buffers:</h3>
<p>Registering provided buffers in the register syscall with <code>IORING_REGISTER_PBUF_RING</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__io_uring_register</span>(<span style="color:#66d9ef">struct</span> io_ring_ctx <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">unsigned</span> opcode,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>arg, <span style="color:#66d9ef">unsigned</span> nr_args)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__releases</span>(ctx<span style="color:#f92672">-&gt;</span>uring_lock)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__acquires</span>(ctx<span style="color:#f92672">-&gt;</span>uring_lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...] 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> IORING_REGISTER_PBUF_RING:
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>arg <span style="color:#f92672">||</span> nr_args <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_register_pbuf_ring</span>(ctx, arg);
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>And <code>io_register_pbuf_ring</code> looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_register_pbuf_ring</span>(<span style="color:#66d9ef">struct</span> io_ring_ctx <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_uring_buf_reg reg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_buffer_list <span style="color:#f92672">*</span>bl, <span style="color:#f92672">*</span>free_bl <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">copy_from_user</span>(<span style="color:#f92672">&amp;</span>reg, arg, <span style="color:#66d9ef">sizeof</span>(reg))) <span style="color:#75715e">// Copying the args from userspace
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	bl <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_buffer_get_list</span>(ctx, reg.bgid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (bl) {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/* if mapped buffer ring OR classic exists, don&#39;t allow */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bl<span style="color:#f92672">-&gt;</span>is_mapped <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">list_empty</span>(<span style="color:#f92672">&amp;</span>bl<span style="color:#f92672">-&gt;</span>buf_list))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EEXIST;
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		free_bl <span style="color:#f92672">=</span> bl <span style="color:#f92672">=</span> <span style="color:#a6e22e">kzalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>bl), GFP_KERNEL); <span style="color:#75715e">// No cache isolation for the io_buffers list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bl)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(reg.flags <span style="color:#f92672">&amp;</span> IOU_PBUF_RING_MMAP))
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_pin_pbuf_ring</span>(<span style="color:#f92672">&amp;</span>reg, bl);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_alloc_pbuf_ring</span>(<span style="color:#f92672">&amp;</span>reg, bl); <span style="color:#75715e">// [6]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ret) {
</span></span><span style="display:flex;"><span>		bl<span style="color:#f92672">-&gt;</span>nr_entries <span style="color:#f92672">=</span> reg.ring_entries;
</span></span><span style="display:flex;"><span>		bl<span style="color:#f92672">-&gt;</span>mask <span style="color:#f92672">=</span> reg.ring_entries <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">io_buffer_add_list</span>(ctx, bl, reg.bgid); <span style="color:#75715e">// [7]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In case arg is flagged with <code>IOU_PBUF_RING_MMAP</code>, it calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_alloc_pbuf_ring</span>(<span style="color:#66d9ef">struct</span> io_uring_buf_reg <span style="color:#f92672">*</span>reg,
</span></span><span style="display:flex;"><span>			      <span style="color:#66d9ef">struct</span> io_buffer_list <span style="color:#f92672">*</span>bl)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">gfp_t</span> gfp <span style="color:#f92672">=</span> GFP_KERNEL_ACCOUNT <span style="color:#f92672">|</span> __GFP_ZERO <span style="color:#f92672">|</span> __GFP_NOWARN <span style="color:#f92672">|</span> __GFP_COMP;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> ring_size;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ring_size <span style="color:#f92672">=</span> reg<span style="color:#f92672">-&gt;</span>ring_entries <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> io_uring_buf_ring);
</span></span><span style="display:flex;"><span>	ptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) <span style="color:#a6e22e">__get_free_pages</span>(gfp, <span style="color:#a6e22e">get_order</span>(ring_size)); <span style="color:#75715e">// [8]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptr)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	bl<span style="color:#f92672">-&gt;</span>buf_ring <span style="color:#f92672">=</span> ptr;
</span></span><span style="display:flex;"><span>	bl<span style="color:#f92672">-&gt;</span>is_mapped <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	bl<span style="color:#f92672">-&gt;</span>is_mmap <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function allocates the necessary memory for the entries using the page allocator <code>__get_free_pages</code> [8], and stores the returned pages address in <code>bl-&gt;buf_ring</code>. <br>
It sets flags <code>is_mapped</code> and <code>is_mmap</code> which 1, which means that these newly allocated buffers are mmaped to userspace. <br>
In [7], <code>bl</code> is then added to to the io_buffers list, which makes it ready for use by mapping it from the userspace:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> file_operations io_uring_fops <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>	.release	<span style="color:#f92672">=</span> io_uring_release,
</span></span><span style="display:flex;"><span>	.mmap		<span style="color:#f92672">=</span> io_uring_mmap,
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span></code></pre></div><h3 id="unregistering-io-buffers">Unregistering io buffers:</h3>
<p>Same as registering, unregistering is handled in <code>__io_uring_register(</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__io_uring_register</span>(<span style="color:#66d9ef">struct</span> io_ring_ctx <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">unsigned</span> opcode,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>arg, <span style="color:#66d9ef">unsigned</span> nr_args)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__releases</span>(ctx<span style="color:#f92672">-&gt;</span>uring_lock)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__acquires</span>(ctx<span style="color:#f92672">-&gt;</span>uring_lock)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...] 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">case</span> IORING_UNREGISTER_PBUF_RING:
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>arg <span style="color:#f92672">||</span> nr_args <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>		ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_unregister_pbuf_ring</span>(ctx, arg); <span style="color:#75715e">// [9]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>In [9], <code>io_unregister_pbuf_ring</code> simply grabs the <code>io_uring_buf_reg</code> arg, and frees its corresponding buffer list <code>bl</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">io_unregister_pbuf_ring</span>(<span style="color:#66d9ef">struct</span> io_ring_ctx <span style="color:#f92672">*</span>ctx, <span style="color:#66d9ef">void</span> __user <span style="color:#f92672">*</span>arg)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_uring_buf_reg reg;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> io_buffer_list <span style="color:#f92672">*</span>bl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">copy_from_user</span>(<span style="color:#f92672">&amp;</span>reg, arg, <span style="color:#66d9ef">sizeof</span>(reg)))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg.resv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">||</span> reg.resv[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">||</span> reg.resv[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (reg.flags)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	bl <span style="color:#f92672">=</span> <span style="color:#a6e22e">io_buffer_get_list</span>(ctx, reg.bgid);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bl)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOENT;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>bl<span style="color:#f92672">-&gt;</span>is_mapped)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">__io_remove_buffers</span>(ctx, bl, <span style="color:#f92672">-</span><span style="color:#ae81ff">1U</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (bl<span style="color:#f92672">-&gt;</span>bgid <span style="color:#f92672">&gt;=</span> BGID_ARRAY) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">xa_erase</span>(<span style="color:#f92672">&amp;</span>ctx<span style="color:#f92672">-&gt;</span>io_bl_xa, bl<span style="color:#f92672">-&gt;</span>bgid);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">kfree</span>(bl);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>bl-&gt;buf_ring</code> is freed with <code>io_remove_buffers</code> -&gt; <code>free_compound_page</code> in [10]:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">__io_remove_buffers</span>(<span style="color:#66d9ef">struct</span> io_ring_ctx <span style="color:#f92672">*</span>ctx,
</span></span><span style="display:flex;"><span>			       <span style="color:#66d9ef">struct</span> io_buffer_list <span style="color:#f92672">*</span>bl, <span style="color:#66d9ef">unsigned</span> nbufs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/* shouldn&#39;t happen */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nbufs)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (bl<span style="color:#f92672">-&gt;</span>is_mapped) {
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">=</span> bl<span style="color:#f92672">-&gt;</span>buf_ring<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">-</span> bl<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (bl<span style="color:#f92672">-&gt;</span>is_mmap) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">struct</span> page <span style="color:#f92672">*</span>page;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			page <span style="color:#f92672">=</span> <span style="color:#a6e22e">virt_to_head_page</span>(bl<span style="color:#f92672">-&gt;</span>buf_ring);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">put_page_testzero</span>(page))
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">free_compound_page</span>(page); <span style="color:#75715e">// [10]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			bl<span style="color:#f92672">-&gt;</span>buf_ring <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>			bl<span style="color:#f92672">-&gt;</span>is_mmap <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>bl-&gt;is_mmap</code> and <code>bl-&gt;is_mapped</code> are reset to 0.</p>
<p>These buffers can be mapped into userspace with flag <code>VM_PFNMAP</code> which means that pages refcount isn&rsquo;t incremented during mmap. <br>
Then after calling <code>free_compound_page</code>, the kernel frees these pages even if they&rsquo;re still mapped in userspace since the refcount isn&rsquo;t incremented, and they are returns into the page allocator. \ Hence, user can still access them: <strong>UAF</strong>. <br>
This is a very powerful exploitation primitive sinice we can do read/write operations on kernel pages which then could be forced into getting reallocated with interesing objects.</p>
<h2 id="exploitation-1">Exploitation:</h2>
<p>There are many exploit strategies that come to mind: f_mode modification, DirtyPTE, PageJacking &hellip;etc or even non data-only like simply ROPing by corruption pipe objects for example.</p>
<p><img src="/Qdiv7/images/io_uring/Recording.gif" alt="Image slab"></p>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://chomp.ie/Blog+Posts/Put+an+io_uring+on+it+-+Exploiting+the+Linux+Kernel">https://chomp.ie/Blog+Posts/Put+an+io_uring+on+it+-+Exploiting+the+Linux+Kernel</a></li>
<li><a href="https://u1f383.github.io/slides/talks/2025_Hexacon-Deja_Vu_in_Linux_io_uring_Breaking_Memory_Sharing_Again_After_Generations_of_Fixes.pdf">https://u1f383.github.io/slides/talks/2025_Hexacon-Deja_Vu_in_Linux_io_uring_Breaking_Memory_Sharing_Again_After_Generations_of_Fixes.pdf</a></li>
<li><a href="https://blog.exodusintel.com/2024/03/27/mind-the-patch-gap-exploiting-an-io_uring-vulnerability-in-ubuntu/">https://blog.exodusintel.com/2024/03/27/mind-the-patch-gap-exploiting-an-io_uring-vulnerability-in-ubuntu/</a></li>
</ul>

        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    
</div>



    

        </main><footer class="footer">
    
    

    

    

    

    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/gokarna-theme/gokarna-hugo">Gokarna</a>
    </span>
</footer>
</body>
</html>
